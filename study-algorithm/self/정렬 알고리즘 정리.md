#Sorting Algoritm

사용자가 지정한 기준에 맞게 최소든 최대든 알맞게 정렬하여 출력하는 알고리즘

## 선택 정렬
* 현재 위치에 저장 될 값의 크기가 작냐, 크냐에 따라 최소 선택 정과 최대 선택 정렬로 구분
* 최소 선택 정렬 - 오름차순으로 정렬
* 최대 선택 정렬 - 내림차순으로 정렬

#### 정렬 로직
1. 정렬 되지 않는 인덱스의 맨 앞부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾음 (처음 시작은 배열의 초기 시작 값)
2. 가장 작은 값을 찾으면 그밧을 현재 인덱스와 교환
3. 다음 인덱스에서 위 과정을 반복

#### 시간 복잡도
* n-1개 , n-2개, .. 1개 를 비교하여 반복
* 즉 O(n^2)

#### 공간 복잡도
* 단 하나의 배열에서 진행하기 때문에 O(n)

#### 구현 코드
``` java
	public int[] selectSort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            int temp = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[temp] >= arr[j]) {
                    temp = j;
                }
            }
            swap(arr, i, temp);
        }
        return arr;
    }
```

## 삽입 정렬
* 현재 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘

#### 정렬 로직
1. 두 번째 인덱스부터 시작
2. 현재 인덱스는 별도의 변수에 저장하고, 비교 인덱스를 현재 인덱스 -1로 잡음
3. 별도로 저장해 둔 삽입을 위한 변수와, 비교 인덱스의 배열 값을 비교
4. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장
5. 비교 인덱스를 -1하여 비교를 반복
6. 만약 삽입 변수가 더크면, 비교 인덱스는 +1에 삽입 변수를 저장

#### 시간 복잡도
* n-1개, n개, ..., 1개를 비교하여 반복
* 정렬 되어있는경우 O(n)
* 정렬 되어 있지 않는경우 O(n^2)

#### 공간 복잡도
* 단 하나의 배열에서 진행하므로 O(n)

#### 구현 코드
```java
	public int[] insertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && key < arr[j]) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
        return arr;
    }
```

## 버블 정렬
* 매번 연속된 두개 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법
* 오름차순일 경우 비교시 마다 큰 값이 뒤로 이동하여, 1바퀴 돌 시 가장 큰 값이 맨 뒤에 저장

#### 정렬 로직
1. 두 번째 인덱스 부터 시작
2. 현재 인덱스 값과, 이전의 인덱스 값을 비교
3. 만약 이전 인덱스가 더 크면, 현재 인덱스와 교환
4. 현재 인덱스가 더 크면, 교환 하지 않고 다음 두 배열값을 비교
5. 전체 배열의 크기 - 현재 순환한 바퀴수 만큼 반복

#### 시간 복잡도
* n-1개, n개, ..., 1개를 비교하여 반복
* O(n^2)

#### 공간 복잡도
* 단 하나의 배열에서 진행하므로 O(n)

#### 구현 코드
```java
	public int[] bubbleSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 1; j < arr.length - i; j++) {
                if (arr[j - 1] > arr[j]) {
                    swap(arr, j - 1, j);
                }
            }
        }
        return arr;
    }
```

## 합병 정렬
* 분할 정복 방식으로 설계된 알고리즘
* 반으로 쪼개 문제를 해결해 나가는 방식으로, 배열의 크기가 1보다 작거나 같을 때 까지 반복
* 입력으로 하나의 배열을 받고, 연산 중에 두개의 배열로 계속 쪼게 나간뒤, 합치면서 정렬해 쵷후에는 하나의 정렬을 출력
* 두개의 배열을 비교하여, 기준에 맞는 값을 다른 배열에 저장해 나간다.

#### 정렬 로직
* 분할 과정의 기본 로직
	1. 현재 배열을 반으로 쪼갬
	2. 배열의 시작 위치와, 종료 위치를 입력받아 둘을 더한 후 2를 나눠 그 위치를 기준으로 나눈다.
	3. 이를 쪼갠 배열의 크기가 0이거나 1일때까지 반복
* 합병 과정의 기본 로직
	1. 두 배열의 크기를 비교, 그리고 각각 시작 인덱스, 시작 주소를 지정
	2. 첫번째 배열과 두번째 배열의 값을 비교 그리고 새로운 배열에 저장
	3. 저장 한 배열의 위치를 +1하여 다시 비교
	4. 서로 비교해 끝까지 도달하도록 반복
	5. 끝까지 저장 못한 배열의 값을, 순서대로 새 배열에 저장
	6. 새 배열을 원래의 배열에 저장

#### 시간 복잡도
* 합병 과정은 두배열을 정렬 하기 때문에 각각 n1, n2라고 가정
	* O(n1+n2) => O(n)
* 분할 과정은 logN만큼 일어남
	* 크기가 N인 배열을 분할하면 N/2, N/2 => 2개
	* 다음 분할시 => N/4, N/4, N/4, N/4 => 4개
	* 즉 logN 만큼 반복
* 따라서 합병과 분할을 같이 하기때문에 O(NlogN)

#### 공간 복잡도
* 배열을 2개 사용하기 때문에 2N

#### 구현 코드
```java
	 public void mergeSort(int[] arr, int start, int end) {
        if (end - start < 2) {
            return;
        }
        int middle = (start + end) / 2;
        mergeSort(arr, start, middle);
        mergeSort(arr, middle, end);

        merge(arr, start, end, middle);
    }

    private void merge(int[] arr, int start, int end, int middle) {
        if (arr[middle - 1] <= arr[middle]) {
            return;
        }

        int i = start;
        int j = middle;
        int copy = 0;

        int[] tempArr = new int[end - start];
        while (i < middle && j < end) {
            if (arr[i] < arr[j]) {
                tempArr[copy++] = arr[i++];
            } else {
                tempArr[copy++] = arr[j++];
            }
        }

        if (i < middle) {
            for (int k = 0; k < middle - i; k++) {
                arr[k + start + copy] = arr[k + i];
            }
        }

        for (int k = 0; k < copy; k++) {
            arr[k + start] = tempArr[k];
        }
    }
```

## 퀵 정렬
* 분할 정복을 이용하여 정렬을 수행하는 알고리즘
* pivot point로 하나의 기준을 설정하고, 이 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮기는 방식
* 이를 반복하여 분할된 배열의 크기가 1이되면 배열이 모두 정렬 된 상태

#### 정렬 로직
1. 배열 값 하나를 pivot point로 잡는다.
2. 분할을 진행하기 앞서, 비교를 진행하기 위해 가장 왼쪽 배열의 인덱스를 저장하는 left 변수, 가장 오른쪽 배열의 인덱스를 저장한 right 변수를 생성
3. right 부터 비교를 진행
4. 비교는 right가 left 보다 클 때만 반복하며 비교한 배열값이 pivot point보다 크면 right 를 하나 감소시키고 비교를 반복
5. 그리고 pivot point보다 작은 배열 값을 찾으면 중지
6. 다음 left를 진행
7. right와 반대로 비교 반복
8. left값과 right 값을 바꿔준다.
9. 다음 과정을 left < right가 만족할때 까지 반복
10. 위 과정이 끝나면  left값과 pivot point를 바꿔준다.
11. 맨 왼쪽부터 left -1 까지, left + 1부터 맨 오른족까지로 나눠 퀵정렬을 반복

#### 시간 복잡도
* 분할과 동시에 정렬을 진행하는 알고리즘
	* 각 정렬은 배열의 크기 N만큼 비교하며, 이를 총 분할 깊이인 logN만큼 진행하므로 총 비교횟수는 NlogN
	* 즉 O(NlogN)
* 최악의 경우는 배열이 이미 정렬이 되어있는 경우
	* 이 경우에는 분할이 N만큼 일어나므로 N^2
	* 즉 O(N^2)
* 합병 정렬보다 느린 알고리즘이라 생각하지만, 발생하기 쉽지 않은 경우이고, 일반적으로 퀵정렬이 합병정렬보다 20%빠르다고 함