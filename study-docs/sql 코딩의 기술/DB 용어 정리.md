# DB 용어 정리

이번 글은  공부하면서 이해가 안갔던 용어들을 정리해 보는 시간을 갖을려고 합니다.



### 데이터베이스 엔진

첫번째로 볼 용어는 데이터베이스 엔진(스토리지 엔진) 입니다. 데이터베이스 엔진은 위키에서 다음과 같이 말합니다.

`데이터베이스 엔진은 DBMS가 데이터를 삽입, 추출, 삭제, 수정을 사용하는 기본 소프트웨어 컴포넌트이다. `

즉 DB에서 데이터를 어떠한 방식으로 저장하고 접근할 것인지, 데이터 접근이 얼마나 빠른지, 얼마나 안정적인지, 트랜잭션 관리 등 시스템을 운영하는 핵심적인 요소라 볼 수 있습니다. 또한 종종 데이터베이스 서버 또는 데이터베이스 관리시스템(DBMS) 라 불리기도 합니다. 

데이터베이스 엔진을 조작하기 위해서는 다음과 같은 방법이 있습니다.

1. DBMS 고유의 사용자 인터페이스를 이용하는 방법
2. 포트 번호를 통해 하는 방법

그럼 예를 들어 MySQL의 데이터베이스 엔진을 살펴 볼까요?

1. **MyISAM**
   1. MySQL의 기본 엔진으로 데이터 저장 제한이 없고 효율적으로 저장을 합니다.
   2. Full-text 인덱스를 지원하고 메모리 캐쉬를 지원합니다.
   3. 트래잭션은 지원하지 않아 잦은 변경 및 삭제에 용이하지 않습니다. (트랜잭션이 없기 때문에 문제가 생기면 DB에 반영이 됌)
   4. 테이블에 있는 특정 row를 작업하려고 하면 테이블 전체에 락이 걸려 다른 사람이 작업 할 수 없습니다. (Table-Level Lock)
   5. 데이터 압축에 대한 옵션을 제공합니다.
   6. 주로 SELECT 작업이 많은 경우에 사용합니다.
2. **InnoDB**
   1. 우리가 많이 사용하는 데이터베이스 엔진입니다.
   2. ACID 트랜잭션을 지원을 해, 저장, 수정, 삭제에 용이합니다.
   3. MyISAM 보다 저장 비율이 낮고, 데이터 로드 속도가 느립니다.
   4. 메모리 캐쉬를 지원합니다.
   5. Table-Level Lock이 아닌 Row-Level Lock을 지원을 하기 때문에 다른 사람이 작업을 할 수 있습니다. (insert, update, delete에 대한 속도가 빠름)
   6. 데이터 압축이 불가능하고 자동 에러 복구 기능이 있습니다.
   7. 주로 데이터 입력 및 수정이 빈번한 높은 퍼포먼스를 요구하는 대용량 어플리케이션에서 사용합니다.
3. **Cluster**
   1. 트랜잭션을 지원합니다.
   2. 모든 데이터와 인덱스가 메모리에 존재하여 매우 빠른 데이터 로드 속도를 할 수 있습니다. (PK 사용시  최상의 속도를 나타냄)
4. **Archive**
   1. MySQL 5.0부터 새롭게 도입된 엔진으로 자동적으로 데이터 압축을 지원하며 다른 엔진에 비해 80% 저장공간 절약효과를 자랑합니다.
   2. 빠른 데이터 로드 속도를 자랑하지만, SELECT, INSERT 에서만 가능합니다.
5. **Federated**
   1. MySQL 5.0부터 새롭게 도입된 엔진으로 물리적 데이터베이스에 대한 논리적 데이터베이스를 생성하여 우너격 데이터를 컨트롤 할 수 있습니다.
   2. 실행속도는 네트워크 요소에 따라 크게 좌우됩니다.
   3. 테이블 정의를 통한 SSL 보안 처리를 합니다.
   4. 주로 분산 데이터베이스 환경에 사용합니다.



### DB 옵티마이저

옵티마이즈의 뜻은 `~을 최대한 좋게(적합하게) 만든다.` 라는 뜻입니다. 즉 수학적으로 풀이하면 어떤 조건 아래에서 주어진 함수가 가능한 최대 또는 최소로 된다는 뜻입니다.  

이렇듯 DB 옵티마이저는 최적화를 수행하는 기능이라고 보면 됩니다. 가장 대표적인 예로 쿼리 최적화가 있을 수 있죠.

( 옵티마이저에 대해 더 알고 싶으면 [여기 클릭](https://byplacebo.tistory.com/39) )

그럼 쿼리 실행 절차에 대해 보도록 합시다.

MySQL의 쿼리가 실행되는 과정은 크게 3가지로 나뉩니다.

1. SQL Parsing을 통해 사용자가 보낸 SQL 문장을 서버가 이해하도록 분리합니다. (SQL Parser 모듈로 처리)
   * 이때 SQL 문법에 오류가 있으며 해당 단계에서 걸러지게 됩니다.
   * Parse Tree를 만들어 서버는 해당 Parse Tree를 이용해 쿼리를 실행합니다.
2. SQL의 Parse Tree를 참조하면서 테이블을 읽을지 선택합니다. 즉 옵티마이저가 실행 계획은 세우는 작업을 합니다. 다음 예를 들어보겠습니다.
   * 필요없는 조건 제거
   * 복잡한 연산 -> 단순화
   * 여러 테이블의 조인이 있는 경우 읽는 순서
   * 사용할 인덱스 결정
   * 가져온 레코드에 대한 임시 테이블의 저장 후 가공
3. 이렇게  실헹 계획을 세운 후 스토리지 엔진으로부터 데이터를 가지고 옵니다.

1, 2 단계는 거의 MySQL 엔진에서 처리하며, 3 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리합니다.

옵티마이저의 종류는 다음과 같습니다.

1. 규칙 기반 최적화
   * 옵티마이저에 내장된 우선 순위에 따라 실행 꼐획을 수립하는 방식
   * 통계 정보 조사x, 실행 계획이 수렵되어 같은 쿼리에 대해서는 항상 같은 실행방법을 만들어 냄
   * 이러한 이유 때문에 오래전부터 DBMS에 지원하지 않음
2. 비용 기반 최적화
   * 쿼리를 처리하기 위한 여러가지 가능한 방법을 만들어 해당 방법들의 비용을 산출해 최소 비용이 드는 쿼리를 실행



### 인덱스

인덱스가 무엇인지는 알지만 정확하게는 잘 몰랐습니다. 그래서 이번 기회에 정리를 하려고 용어 정리에 넣었습니다.

인덱스는 다음과 같이 설명할 수 있습니다.

`인덱스 = 정렬`

 즉 지정한 컬럼들을 기준으로 메모리 영역에서 일종의 목차를 만든다고 보면 됩니다. 그럼 인덱스는 왜 만드는 것일까요?

인덱스를 만드는 이유는 다음과 같습니다.

`SELECT의 성능 향상`

즉 Update, Delete의 행위의 성능을 포기하고 Read의 성능을 향상시키게 하기 위해 인덱스를 사용합니다.

